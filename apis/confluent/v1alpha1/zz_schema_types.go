// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type SchemaCredentialsInitParameters struct {
}

type SchemaCredentialsObservation struct {
}

type SchemaCredentialsParameters struct {

	// The Schema Registry API Key.
	// The Cluster API Key for your Confluent Cloud cluster.
	// +kubebuilder:validation:Required
	KeySecretRef v1.SecretKeySelector `json:"keySecretRef" tf:"-"`

	// The Schema Registry API Secret.
	// The Cluster API Secret for your Confluent Cloud cluster.
	// +kubebuilder:validation:Required
	SecretSecretRef v1.SecretKeySelector `json:"secretSecretRef" tf:"-"`
}

type SchemaInitParameters struct {

	// supports the following:
	// The Cluster API Credentials.
	Credentials []SchemaCredentialsInitParameters `json:"credentials,omitempty" tf:"credentials,omitempty"`

	// The format of the schema. Accepted values are: AVRO, PROTOBUF, and JSON.
	// The format of the Schema.
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// An optional flag to control whether a schema should be soft or hard deleted. Set it to true if you want to hard delete a schema on destroy (see Schema Deletion Guidelines for more details). Must be unset when importing. Defaults to false (soft delete).
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete). Defaults to `false`.
	HardDelete *bool `json:"hardDelete,omitempty" tf:"hard_delete,omitempty"`

	// An optional flag to control whether a schema should be recreated on an update. Set it to true if you want to manage different schema versions using different resource instances. Must be set to the target value when importing. Defaults to false, which manages the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates.
	// Controls whether a schema should be recreated on update. Defaults to `false`.
	RecreateOnUpdate *bool `json:"recreateOnUpdate,omitempty" tf:"recreate_on_update,omitempty"`

	// The REST endpoint of the Schema Registry cluster, for example, https://psrc-00000.us-central1.gcp.confluent.cloud:443).
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint *string `json:"restEndpoint,omitempty" tf:"rest_endpoint,omitempty"`

	// The schema string, for example, file("./schema_version_1.avsc").
	// The definition of the Schema.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The list of referenced schemas (see Schema References for more details):
	// The list of references to other Schemas.
	SchemaReference []SchemaReferenceInitParameters `json:"schemaReference,omitempty" tf:"schema_reference,omitempty"`

	// supports the following:
	SchemaRegistryCluster []SchemaRegistryClusterInitParameters `json:"schemaRegistryCluster,omitempty" tf:"schema_registry_cluster,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the Schema Registry Subject.
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`
}

type SchemaObservation struct {

	// supports the following:
	// The Cluster API Credentials.
	Credentials []SchemaCredentialsParameters `json:"credentials,omitempty" tf:"credentials,omitempty"`

	// The format of the schema. Accepted values are: AVRO, PROTOBUF, and JSON.
	// The format of the Schema.
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// An optional flag to control whether a schema should be soft or hard deleted. Set it to true if you want to hard delete a schema on destroy (see Schema Deletion Guidelines for more details). Must be unset when importing. Defaults to false (soft delete).
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete). Defaults to `false`.
	HardDelete *bool `json:"hardDelete,omitempty" tf:"hard_delete,omitempty"`

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// An optional flag to control whether a schema should be recreated on an update. Set it to true if you want to manage different schema versions using different resource instances. Must be set to the target value when importing. Defaults to false, which manages the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates.
	// Controls whether a schema should be recreated on update. Defaults to `false`.
	RecreateOnUpdate *bool `json:"recreateOnUpdate,omitempty" tf:"recreate_on_update,omitempty"`

	// The REST endpoint of the Schema Registry cluster, for example, https://psrc-00000.us-central1.gcp.confluent.cloud:443).
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint *string `json:"restEndpoint,omitempty" tf:"rest_endpoint,omitempty"`

	// The schema string, for example, file("./schema_version_1.avsc").
	// The definition of the Schema.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The globally unique ID of the Schema, for example, 100003. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects.
	// Globally unique identifier of the Schema returned for a creation request. It should be used to retrieve this schema from the schemas resource and is different from the schemaâ€™s version which is associated with the subject.
	SchemaIdentifier *float64 `json:"schemaIdentifier,omitempty" tf:"schema_identifier,omitempty"`

	// The list of referenced schemas (see Schema References for more details):
	// The list of references to other Schemas.
	SchemaReference []SchemaReferenceObservation `json:"schemaReference,omitempty" tf:"schema_reference,omitempty"`

	// supports the following:
	SchemaRegistryCluster []SchemaRegistryClusterObservation `json:"schemaRegistryCluster,omitempty" tf:"schema_registry_cluster,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the Schema Registry Subject.
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version number of the Schema.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SchemaParameters struct {

	// supports the following:
	// The Cluster API Credentials.
	// +kubebuilder:validation:Optional
	Credentials []SchemaCredentialsParameters `json:"credentials,omitempty" tf:"credentials,omitempty"`

	// The format of the schema. Accepted values are: AVRO, PROTOBUF, and JSON.
	// The format of the Schema.
	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// An optional flag to control whether a schema should be soft or hard deleted. Set it to true if you want to hard delete a schema on destroy (see Schema Deletion Guidelines for more details). Must be unset when importing. Defaults to false (soft delete).
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete). Defaults to `false`.
	// +kubebuilder:validation:Optional
	HardDelete *bool `json:"hardDelete,omitempty" tf:"hard_delete,omitempty"`

	// An optional flag to control whether a schema should be recreated on an update. Set it to true if you want to manage different schema versions using different resource instances. Must be set to the target value when importing. Defaults to false, which manages the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates.
	// Controls whether a schema should be recreated on update. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RecreateOnUpdate *bool `json:"recreateOnUpdate,omitempty" tf:"recreate_on_update,omitempty"`

	// The REST endpoint of the Schema Registry cluster, for example, https://psrc-00000.us-central1.gcp.confluent.cloud:443).
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	// +kubebuilder:validation:Optional
	RestEndpoint *string `json:"restEndpoint,omitempty" tf:"rest_endpoint,omitempty"`

	// The schema string, for example, file("./schema_version_1.avsc").
	// The definition of the Schema.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The list of referenced schemas (see Schema References for more details):
	// The list of references to other Schemas.
	// +kubebuilder:validation:Optional
	SchemaReference []SchemaReferenceParameters `json:"schemaReference,omitempty" tf:"schema_reference,omitempty"`

	// supports the following:
	// +kubebuilder:validation:Optional
	SchemaRegistryCluster []SchemaRegistryClusterParameters `json:"schemaRegistryCluster,omitempty" tf:"schema_registry_cluster,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the Schema Registry Subject.
	// +kubebuilder:validation:Optional
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`
}

type SchemaReferenceInitParameters struct {

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the referenced Schema Registry Subject (for example, "User").
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version of the referenced Schema.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SchemaReferenceObservation struct {

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the referenced Schema Registry Subject (for example, "User").
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version of the referenced Schema.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SchemaReferenceParameters struct {

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the referenced Schema Registry Subject (for example, "User").
	// +kubebuilder:validation:Optional
	SubjectName *string `json:"subjectName" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version of the referenced Schema.
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version" tf:"version,omitempty"`
}

type SchemaRegistryClusterInitParameters struct {

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	// The Schema Registry cluster ID (e.g., `lsrc-abc123`).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SchemaRegistryClusterObservation struct {

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	// The Schema Registry cluster ID (e.g., `lsrc-abc123`).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SchemaRegistryClusterParameters struct {

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	// The Schema Registry cluster ID (e.g., `lsrc-abc123`).
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`
}

// SchemaSpec defines the desired state of Schema
type SchemaSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SchemaParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SchemaInitParameters `json:"initProvider,omitempty"`
}

// SchemaStatus defines the observed state of Schema.
type SchemaStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SchemaObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Schema is the Schema for the Schemas API.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,confluent}
type Schema struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.format) || (has(self.initProvider) && has(self.initProvider.format))",message="spec.forProvider.format is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.subjectName) || (has(self.initProvider) && has(self.initProvider.subjectName))",message="spec.forProvider.subjectName is a required parameter"
	Spec   SchemaSpec   `json:"spec"`
	Status SchemaStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SchemaList contains a list of Schemas
type SchemaList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Schema `json:"items"`
}

// Repository type metadata.
var (
	Schema_Kind             = "Schema"
	Schema_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Schema_Kind}.String()
	Schema_KindAPIVersion   = Schema_Kind + "." + CRDGroupVersion.String()
	Schema_GroupVersionKind = CRDGroupVersion.WithKind(Schema_Kind)
)

func init() {
	SchemeBuilder.Register(&Schema{}, &SchemaList{})
}
